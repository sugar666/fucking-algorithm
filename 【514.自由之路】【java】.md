# 【514.自由之路】【java】
![514.自由之路](media/16050654490756/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-11-11%2011.32.44.png)


## 深度优先遍历
圆盘可以从两边进行旋转，一步优不一定步步优，需要对每一种情况进行罗列，找到最优的步数

```java
class Solution {

    HashMap<Character,List<Integer>> map = new HashMap<>();
    int res = Integer.MAX_VALUE;
    public int findRotateSteps(String ring, String key) 

        // 使用map储存对应char的索引，便于查找
        for(int i = 0;i < ring.length();i++) {
            char temp = ring.charAt(i);
            
            if(map.containsKey(temp)) {
                List<Integer> list = map.get(temp);
                list.add(i);
                map.put(temp,list);
            }else {
                List<Integer> list = new ArrayList<>();
                list.add(i);
                map.put(temp,list);
            }
        }
        dfs(ring,key,0,0,0);
        return res;
    }

    /**
     * 
     * @param ring : 圆盘String
     * @param key ：目标String
     * @param startIndex ： ring中起始的index
     * @param keyIndex ：需要找到key中的值
     * @param len ：旋转需要的步骤
     */
    public void dfs(String ring,String key,int startIndex,int keyIndex,int len) {
        if(keyIndex == key.length()) {
            res = Math.min(res,len);
            return;
        }
        char temp = key.charAt(keyIndex);
        // 对应temp映射到的索引集合
        List<Integer> list = map.get(temp);
        for(int i = 0;i < list.size();i++) {
            int index = list.get(i);
            // 顺时针旋转
            dfs(ring,key,index,keyIndex + 1,len + Math.abs(index - startIndex) + 1);
            // 逆时针查找
            dfs(ring,key,index,keyIndex + 1,len + ring.length() - Math.abs(index - startIndex) + 1);
        }
    }
}
```
**直接使用上面的方法会超出时间限制**
可以使用数组，保存dfs中间执行的结果。

## 优化：记忆化搜索
使用`memo[][]`保存中间结果

```java
class Solution {

    HashMap<Character,List<Integer>> map = new HashMap<>();
    
    int[][] memo;
    public int findRotateSteps(String ring, String key) {

        // 查找到对应char的索引
        for(int i = 0;i < ring.length();i++) {
            char temp = ring.charAt(i);
            
            if(map.containsKey(temp)) {
                List<Integer> list = map.get(temp);
                list.add(i);
                map.put(temp,list);
            }else {
                List<Integer> list = new ArrayList<>();
                list.add(i);
                map.put(temp,list);
            }
        }
        memo = new int[ring.length()][key.length()];
        return dfs(ring,key,0,0);

    }

    public int dfs(String ring,String key,int startIndex,int keyIndex) {
        if(keyIndex == key.length()) { 
            return 0;
        }
        if(memo[startIndex][keyIndex] != 0) {
            return memo[startIndex][keyIndex];
        }
        char temp = key.charAt(keyIndex);
        List<Integer> list = map.get(temp);
        int res = Integer.MAX_VALUE;
        for(int i = 0;i < list.size();i++) {
            int index = list.get(i);
            
            int dfsRes = dfs(ring,key,index,keyIndex + 1);
            // ring向右旋转（顺时针）需要的步数
            int right =  dfsRes + Math.abs(index - startIndex) + 1;
            // ring向左旋转（逆时针）需要的步数
            int left = dfsRes+ ring.length() - Math.abs(index - startIndex) + 1;

            res = Math.min(res,Math.min(left,right));
        }
        memo[startIndex][keyIndex] = res;
        return res;
    }
}
```